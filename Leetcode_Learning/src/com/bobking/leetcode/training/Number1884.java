package com.bobking.leetcode.training;

public class Number1884 {

    // 参考：https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/solution/shuang-dan-diao-luo-_java_dong-tai-gui-h-7b2l/
    public int twoEggDrop(int n) {

        // 手中一共有两枚鸡蛋。假如从第 i 层扔下去(0 < i <= n)，那么会有两种可能，一种是鸡蛋碎了，另一种是鸡蛋没碎
        // 鸡蛋碎了：那么手中还有 1 枚鸡蛋，为了确保能准确的得知鸡蛋刚好摔碎的层数，只能从第一层开始尝试，所以最坏的结果就是尝试 i - 1 次
        // 因为第一枚鸡蛋是从第 i 层摔碎的，所以要尝试 1 ~ i - 1 的所有层数，再加上第 i 层扔的一次，尝试次数就是 i - 1 + 1 = i

        // 鸡蛋没碎: 那么手中还是有两枚鸡蛋，仍可以去任意尝试层数，并且当前的范围缩小到 i + 1 ~ n (一共是 n - i 层)
        // 因为第 i 层没有摔碎，则说明第 i 层及以下不可能摔碎，那么当前问题就变成了求解层数为 n - i 层有两枚鸡蛋，最小操作次数是多少
        // 把 i 层当作是 0 层，i + 1 当作是 1 层..... n - i 就是新问题的总层数
        // 这时候已经发现，当前所求的 n 层建筑两枚鸡蛋的最小操作次数，是与层数为 n - i 层有两枚鸡蛋的最小操作次数之间是有联系的
        // 经典的通过局部最优解推导整体最优解，就说明要用动态规划来解决这个问题了
        // 所以，就可以假设这个楼的层数为 i (i 从 1 开始到 n 结束，包含 n)，尝试求解 i 层楼中每一层扔下鸡蛋需要尝试的次数
        // 比如 i 为 5，那么就 1 ~ 5层都试一遍，求出五个值，求解出 i 层楼需要的最小操作次数
        // 说白了就是先求出总高为 1 的层数的最小操作次数，再根据(总高为 1 层的最小操作次数)求解出总高为 2 层的最小操作次数
        // 以此类推直到求解出 n 层的最小操作次数

        int[] dp = new int[n + 1];
        dp[0] = 0;

        for (int i = 1; i <= n; i++) {

            int min = Integer.MAX_VALUE;

            for (int j = 1; j <= i; j++)
                // Math.max(dp[i - j] + 1, j) 这里的 dp[i - j] + 1 即代表没摔碎(这里的 + 1是代表当前扔了一次，次数要加 1)
                // j 代表摔碎了，要从第 0 层挨个试了
                // 取最大值 max 是因为在寻找最坏的情况
                min = Math.min(Math.max(dp[i - j] + 1, j), min);

            dp[i] = min;
        }

        return dp[n];
    }
}
